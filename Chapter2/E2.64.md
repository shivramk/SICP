#####A. 
The idea behind `parallel-tree` is simple. Consider the list `(1 2 3)`.  A
balanced binary tree for this list should look like \ref{E2_64_1}

![Tree for (1 2 3)\label{E2_64_1}](Chapter2/images/E2_64_1)

The middle element from the list (2) becomes the root. Elements to the left of
2 (1) become go into the left subtree. Elements to the right of 2 (3) go into
the right subtree. 

In general for any given list the center element from the list becomes the
root. Elements to the left of center go into the left subtree and elements to
the right of centre go into the right subtree. This process can be applied
recursively to contruct the complete tree. Keep in mind that for this to work
the list must be ordered. This is exactly what `parallel-tree` does. It
partitions the list into three parts as described. There is a recursive call to
process elements to left of center.  Then another recursive call to process
elements to the right of center. Finally it constructs the tree with center
element of the list as root and the left and right subtrees generated by the
recursive calls.

The tree produced by `list->tree` for the list `(1 3 5 7 9 11)` \ref{E2_64_2}

![Tree for (1 3 5 7 9 11)\label{E2_64_2}](Chapter2/images/E2_64_2)

#####B. 
The order of growth is $O(n)$ where is n is the number of elements in the
list. This is because the procedure recurses for every single element of the
list and each call of partial-tree takes contstant time (for all processing
other than the recursive calls).
